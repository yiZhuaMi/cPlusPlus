// #面试题41. 数据流中的中位数
// 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之
// 后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
// 例如，
// [2,3,4] 的中位数是 3
// [2,3] 的中位数是 (2 + 3) / 2 = 2.5
// 设计一个支持以下两种操作的数据结构：
// void addNum(int num) - 从数据流中添加一个整数到数据结构中。
// double findMedian() - 返回目前所有元素的中位数。


#include <iostream>
#include <queue>
using namespace std;

// 维持一个大顶堆和小顶堆，确保：
// 1、大小顶堆元素数量差小于等于1
// 2、大顶堆中所有元素均小于小顶堆中元素
// 返回结果：
// 大小顶堆元素数量相等时，返回两个堆顶的平均值，否则返回较长堆的堆顶。

// 最大优先队列，无论入队顺序，当前最大的元素优先出队。
// 最小优先队列，无论入队顺序，当前最小的元素优先出队。
// 事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：
//     小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；
//     大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；

class MedianFinder {
public:
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    priority_queue<int,vector<int>,greater<int>> lo;// 小根堆，存更大的一半
    priority_queue<int,vector<int>,less<int> >  hi;// 大根堆，存更小的一半
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    MedianFinder() {

    }
    
    void addNum(int num) {
        // 先将数据加入大根堆，（经过自动排序）再将大根堆top转移到小根堆
        // 这样就确保大根堆都比小根堆的小
        hi.push(num);
        lo.push(hi.top());// 最大的优先给小根堆
        hi.pop();

        while (hi.size() < lo.size())// 保证 大根堆数量 >= 小根堆数量 且数量相差<=1 (否则都会集中到lo中)
        {
            hi.push(lo.top());
            lo.pop();
        }
    }
    
    double findMedian() {
        return (hi.size() + lo.size()) % 2 ? hi.top() : (hi.top() + lo.top()) / 2.0;
    }
};